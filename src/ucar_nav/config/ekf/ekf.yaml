# -----------------------------------------------------------
# ekf.yaml: robot_localization EKF 配置文件
# 专为融合轮式里程计(/odom)和IMU(/imu)以优化里程计设计
# -----------------------------------------------------------

# ---- 1. 全局和坐标系参数 (Global & Frame Parameters) ----

# 滤波器节点的运行频率 (Hz)。通常设置为30-50Hz。
frequency: 30

# 传感器数据超时时间(秒)。如果某个传感器的数据超过这个时间没更新，EKF会停止使用它直到新数据到达。
sensor_timeout: 0.1

# !!! 关键参数 !!!
# 对于在平面上移动的地面机器人，必须设置为true。
# 这会将状态估计强制约束在2D平面上，忽略Z轴、roll、pitch的微小变化，
# 极大地提高了定位的稳定性，防止机器人模型在RViz中“点头”或“翘起”。
two_d_mode: true

# --- 坐标系定义 ---
# EKF输出的里程计的世界坐标系。对于纯里程计融合，我们用 "odom"。
map_frame: odom

# EKF输出的里程计的自身坐标系。同样，设为 "odom"。
# EKF节点本身不会发布 map->odom 的变换，这是AMCL的工作。
odom_frame: odom

# 机器人的基座坐标系。通常是 "base_link" 或 "base_footprint"。
# 请确保这个值和你的URDF模型以及其他ROS节点使用的基座坐标系名称一致。
base_link_frame: base_link

# EKF发布哪个坐标系下的里程计信息。在 two_d_mode 下，这个必须和 odom_frame 一致。
world_frame: odom

# !!! 关键参数 !!!
# 是否让 EKF 节点发布 odom -> base_link 的TF变换。
# 必须设置为 true！这样EKF才能接管并发布那个经过融合、更准确的里程计TF。
publish_tf: true


# ---- 2. 传感器数据源配置 (Sensor Data Configuration) ----
# 这里我们定义要融合哪些传感器。我们有两个：odom0 和 imu0。

# --- Odom0: 你的轮式里程计 ---
odom0: /odom  # 这是你发布的轮式里程计话题名

# `_config` 矩阵是精髓所在。它是一个1x15的布尔矩阵，决定这个传感器
# 的哪些变量被用于状态估计。顺序如下：
# [X, Y, Z,  roll, pitch, yaw,  Vx, Vy, Vz,  Vroll, Vpitch, Vyaw,  Ax, Ay, Az]
# (位置----) (姿态-----------) (线速度------) (角速度-------------) (线性加速度----)
odom0_config: [false, false, false,
               false, false, false,
               true,  true,  false,  # 我们只相信轮式里程计提供的X、Y方向的速度
               false, false, true,   # 以及它提供的Z轴角速度(偏航速率)
               false, false, false]
# 为什么这么设置?
# - 位置(X, Y, Z)和姿态(roll, pitch, yaw)会随时间累积误差，所以设为false，不直接使用。
# - 速度信息是轮式里程计最直接、最可靠的测量值，所以Vx, Vy, Vyaw设为true。
# - 您的机器人是全向轮，其侧向速度Vy是真实存在的，所以必须设为true。
# - Z方向速度Vz和另外两个角速度Vroll, Vpitch对地面机器人无意义，设为false。

# odom消息中的速度是直接测量值，而不是从位置信息中微分出来的，所以设为false。
odom0_differential: false


# --- IMU0: 你的IMU ---
imu0: /imu  # 这是你发布的IMU话题名，根据你的rostopic echo，话题名是/imu

# `_config` 矩阵配置
imu0_config: [false, false, false,
              false, false, false,  # 不使用IMU的任何绝对姿态信息
              false, false, false,
              false, false, true,   # 只使用IMU提供的Yaw轴角速度 (Vyaw)
              false, false, false]  # 不使用IMU的任何线性加速度信息
# 为什么这么设置?
# - 姿态(roll, pitch, yaw)全部设为false:
#   - 在two_d_mode下, roll和pitch被强制为0，融合它们毫无意义且可能引入噪声。
#   - 您的数据显示IMU的绝对yaw角不可靠（协方差极大），因此绝不能使用。
# - 角速度(Vroll, Vpitch, Vyaw)只使用Vyaw:
#   - IMU的yaw角速度是其最准确的数据之一，能极好地修正车轮打滑时的航向估计。
#   - Vroll和Vpitch在2D模式下应为0，融合它们的传感器噪声没有意义。
# - 线性加速度(Ax, Ay, Az)全部设为false:
#   - 加速度计数据通常包含较大噪声。为了构建一个最稳定、最简单的基线系统，我们暂时不使用它。

# IMU的姿态是绝对测量值（相对于重力），不是差分值，所以设为false。
imu0_differential: false

# !!! 关键参数 !!!
# 您的IMU数据显示，Z轴加速度在-9.7左右，明显包含了重力。
# 必须将此项设为true，EKF会根据姿态估计来减去重力分量，从而得到纯粹的机器人运动加速度。
# 虽然我们没有融合加速度，但这个参数是一个良好的实践，以备未来使用。
imu0_remove_gravitational_acceleration: true


# ---- 3. 过程噪声协方差 (Process Noise Covariance) ----
# 这个参数定义了滤波器对自身运动模型的信任程度。
# 值越大，意味着模型越不可靠，滤波器会更倾向于相信传感器的测量值。
# 初学者可以先保持默认值。如果感觉滤波后的里程计响应迟钝，可以适当调大对角线上的值。
process_noise_covariance: [0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.06, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.03, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.03, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.06, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.025, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.025, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.015]


# Initial Estimate Covariance
initial_estimate_covariance:
  [1e-9, 0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
   0,    1e-9, 0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
   0,    0,    1e-9, 0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
   0,    0,    0,    1e-9, 0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
   0,    0,    0,    0,    1e-9, 0,    0,    0,    0,    0,     0,     0,     0,    0,    0,
   0,    0,    0,    0,    0,    1e-9, 0,    0,    0,    0,     0,     0,     0,    0,    0,
   0,    0,    0,    0,    0,    0,    1e-9, 0,    0,    0,     0,     0,     0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    1e-9, 0,    0,     0,     0,     0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    1e-9, 0,     0,     0,     0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    1e-9,  0,     0,     0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     1e-9,  0,     0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     1e-9,  0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     1.0,  0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    1.0,  0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,     0,     0,     0,    0,    1.0]